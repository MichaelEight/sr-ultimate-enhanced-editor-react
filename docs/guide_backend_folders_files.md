FOLLOWING GUIDE WAS GENERATED BY CHATGPT

# Project Folder Structure Guide

Welcome to the project! This document outlines the folder structure, the purpose of each directory and file, and guidelines on where to add new code. Please follow this structure to maintain clarity and consistency across the project.

---

## Root Directory Structure

```plaintext
your_project/
├── app.py
├── uploaded/
├── extracted/
├── exported/
├── logs/
├── app/
│   ├── __init__.py
│   ├── config.py
│   ├── models.py
│   ├── routes.py
│   ├── extensions.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── file_utils.py
│   │   ├── logging_utils.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── project_service.py
│   ├── validation/
│   │   ├── __init__.py
│   │   ├── validators.py
│   └── parsing/
│       ├── __init__.py
│       ├── parsers.py
```

---

## Directory and File Explanations

### 1. **Root Directory**
   - **app.py**: The entry point for the Flask application. This file initializes the server and starts the app.
   - **uploaded/**: This directory stores user-uploaded files. Typically, ZIP archives that are uploaded by users are placed here.
   - **extracted/**: After uploading, files are extracted into this directory for further processing.
   - **exported/**: Files are stored here after being processed and packaged for export (e.g., ZIP archives ready for download).
   - **logs/**: Contains logs generated by the application. Each log is stored in a date-based subdirectory for easy tracking.

### 2. **app/**: This is the main application package where all core logic resides.
   - **__init__.py**: Initializes the Flask application, registers routes, and sets up any extensions.
   - **config.py**: Contains configuration variables for the app (e.g., directories, default file structures, logging levels).
   - **models.py**: Defines core models used by the app, such as the `Project` class. Models encapsulate the data structure and logic related to the project.
   - **routes.py**: Contains all route handlers (API endpoints). This is where you define how requests are processed and what responses are returned.
   - **extensions.py**: Contains the initialization of Flask extensions (e.g., Flask-SocketIO).

### 3. **app/utils/**: Utility functions that support various functionalities in the application.
   - **file_utils.py**: Functions for file handling operations (e.g., copying files, creating ZIP archives).
   - **logging_utils.py**: Functions related to logging (e.g., adding log entries, managing log directories).
   
   **Where to add new utilities**: If you need to add a utility function that supports file handling or logging, it should go here. Create a new utility module if necessary, and ensure the module name clearly reflects its purpose.

### 4. **app/services/**: This directory contains business logic (service layer) that handles complex tasks not tied to HTTP requests or utilities.
   - **project_service.py**: Handles logic related to project management, such as processing files for export, updating file structures, and ensuring project integrity.
   
   **Where to add new services**: If you have any non-trivial logic that doesn’t belong in routes or models, consider adding a service here. For example, adding a `scenario_service.py` for scenario-related logic would be appropriate.

### 5. **app/validation/**: This directory contains functions for input validation, file existence checks, and other validation logic.
   - **validators.py**: Contains validation logic, such as ensuring that required files exist and checking the correctness of uploaded data.
   
   **Where to add new validation logic**: If you need to add new validation rules (e.g., validating user input, file formats), create a new validator or add to `validators.py`.

### 6. **app/parsing/**: Functions responsible for parsing and extracting information from files (e.g., `.SCENARIO` files).
   - **parsers.py**: Functions for reading and parsing files, extracting relevant data into a structured format.
   
   **Where to add new parsers**: Any new logic related to file parsing should go here. If you are working with new file formats or need more parsing functionality, add or modify functions in this module.

---

## Guidelines for Contributing

### Adding New Features

1. **Routing**: Add new API endpoints in `app/routes.py` and ensure each route is well-documented with a clear description of its functionality.
2. **Business Logic**: When adding complex logic, try to place it in the `services/` directory rather than embedding it in routes or models. This keeps the code modular and maintainable.
3. **Utilities**: Place reusable utility functions in `app/utils/`. If the functionality relates to file handling, place it in `file_utils.py`. For logging, use `logging_utils.py`.

### Adding New Modules

If your feature requires new functionality that doesn't fit into an existing file:
- **Services**: If you're adding new functionality that handles core business logic, create a new service module in `app/services/`.
- **Utilities**: If you're adding a reusable utility that supports multiple parts of the app, create a new module under `app/utils/`.
- **Validation**: New validation logic can go into a new file in `app/validation/`, depending on the complexity and scope.
- **Parsers**: If you’re parsing a new type of file, add the relevant parsing functions to `app/parsing/`.

### Maintaining Consistency

- **Naming Conventions**: Use descriptive file and function names. Ensure that new files and directories follow the naming patterns already established.
- **Documentation**: Document your code thoroughly using comments and docstrings. Ensure each function has a clear description of its purpose and parameters.
- **Logging**: Use the logging utilities in `app/utils/logging_utils.py` for consistent log entries. All major actions (e.g., file processing, errors) should be logged.
- **Code Style**: Follow the PEP 8 style guide for Python code, ensuring consistency across the project. Use linting tools like `flake8` to check your code before submitting.

### Testing

Make sure to test any new functionality thoroughly. If you add new routes or services, write tests that verify the correctness of the logic. While formal tests (like unit tests) may not be implemented yet, ensure manual testing is done before committing.

---

## Example Contribution Workflow

1. **Create a New Feature**: You’ve been tasked with adding a new endpoint to upload configuration files.
2. **Add the Route**: Define the new route in `app/routes.py` (e.g., `/upload_config`).
3. **Add Business Logic**: If the logic for handling configuration files is complex (e.g., file parsing, validation), add the core functionality in `app/services/config_service.py`.
4. **Add Utility Functions**: If there are any file-handling operations, you can add them to `app/utils/file_utils.py`.
5. **Test**: Test the new route manually or write unit tests. Ensure all the edge cases are handled, and logs are generated for important actions.
6. **Commit**: Once tested, commit the code with a clear and concise message. Make sure it follows the project’s contribution guidelines.

---

## Conclusion

By following these guidelines, we ensure that our project remains clean, modular, and scalable. If you have any questions, feel free to reach out to the project maintainers. Happy coding!